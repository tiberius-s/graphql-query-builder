/**
 * graphql-query-builder
 *
 * Cache Module
 *
 * Provides LRU caching for built queries to avoid redundant string generation.
 * Uses MD5 hashing for efficient cache key generation.
 */

import { createHash } from 'node:crypto';
import type { BuiltQuery, QueryBuildOptions } from './builder.js';
import type { FieldSelection } from './extractor.js';

/**
 * Cache configuration options.
 */
export interface CacheConfig {
  /** Maximum number of queries to cache (default: 1000) */
  maxSize: number;
  /** Time-to-live in milliseconds, 0 for no expiry (default: 0) */
  ttl: number;
}

/**
 * Cache statistics.
 */
export interface CacheStats {
  hits: number;
  misses: number;
  size: number;
  hitRatio: number;
}

interface CacheEntry {
  query: BuiltQuery;
  timestamp: number;
}

const DEFAULT_CONFIG: CacheConfig = {
  maxSize: 1000,
  ttl: 0,
};

let cache: Map<string, CacheEntry> | null = null;
let config: CacheConfig = { ...DEFAULT_CONFIG };
let stats: CacheStats = { hits: 0, misses: 0, size: 0, hitRatio: 0 };

/**
 * Initializes the query cache with the specified configuration.
 *
 * The cache uses an LRU (Least Recently Used) eviction strategy and optionally
 * supports TTL (time-to-live) for automatic expiration of entries.
 *
 * @param options - Cache configuration options
 * @param options.maxSize - Maximum number of queries to cache (default: 1000)
 * @param options.ttl - Time-to-live in milliseconds, 0 for no expiry (default: 0)
 *
 * @example
 * ```typescript
 * // Cache up to 500 queries with no expiration
 * initializeCache({ maxSize: 500 });
 *
 * // Cache with 1 minute TTL
 * initializeCache({ maxSize: 1000, ttl: 60000 });
 * ```
 *
 * @remarks
 * Calling this function will clear any existing cache and reset statistics.
 *
 * @see {@link clearCache} to clear the cache without changing configuration
 * @see {@link disableCache} to completely disable caching
 */
export function initializeCache(options: Partial<CacheConfig> = {}): void {
  config = { ...DEFAULT_CONFIG, ...options };
  cache = new Map();
  stats = { hits: 0, misses: 0, size: 0, hitRatio: 0 };
}

/**
 * Clears all cached queries while preserving cache configuration.
 *
 * Use this function to invalidate all cached queries without disabling
 * the cache or changing its configuration. Statistics are partially reset
 * (size is set to 0, but hits/misses remain).
 *
 * @example
 * ```typescript
 * // Clear cache after a schema update
 * clearCache();
 * ```
 *
 * @see {@link disableCache} to completely disable caching
 * @see {@link initializeCache} to reinitialize with new configuration
 */
export function clearCache(): void {
  cache?.clear();
  stats.size = 0;
}

/**
 * Completely disables the query cache.
 *
 * After calling this function, {@link buildQueryCached} will fall back to
 * {@link buildQuery}, bypassing caching entirely. All cache entries and
 * statistics are cleared.
 *
 * @example
 * ```typescript
 * // Disable caching for testing
 * disableCache();
 * ```
 *
 * @see {@link initializeCache} to re-enable caching
 * @see {@link isCacheEnabled} to check cache status
 */
export function disableCache(): void {
  cache = null;
  stats = { hits: 0, misses: 0, size: 0, hitRatio: 0 };
}

/**
 * Checks whether caching is currently enabled.
 *
 * @returns `true` if cache is initialized and active, `false` otherwise
 *
 * @example
 * ```typescript
 * if (isCacheEnabled()) {
 *   console.log('Cache is active');
 * }
 * ```
 *
 * @see {@link initializeCache} to enable caching
 * @see {@link disableCache} to disable caching
 */
export function isCacheEnabled(): boolean {
  return cache !== null;
}

/**
 * Retrieves current cache statistics.
 *
 * Statistics include hit/miss counts, cache size, and hit ratio. This is useful
 * for monitoring cache effectiveness and tuning cache configuration.
 *
 * @returns A snapshot of current cache statistics
 * @returns stats.hits - Number of successful cache retrievals
 * @returns stats.misses - Number of cache misses
 * @returns stats.size - Current number of cached queries
 * @returns stats.hitRatio - Ratio of hits to total lookups (0-1)
 *
 * @example
 * ```typescript
 * const stats = getCacheStats();
 * console.log(`Cache hit ratio: ${(stats.hitRatio * 100).toFixed(2)}%`);
 * console.log(`Cache size: ${stats.size}/${config.maxSize}`);
 * ```
 *
 * @remarks
 * Returns a copy of the stats object to prevent external modification.
 */
export function getCacheStats(): CacheStats {
  return { ...stats };
}

/**
 * Generates an MD5 hash for a cache key.
 */
function md5(input: string): string {
  return createHash('md5').update(input).digest('hex');
}

/**
 * Generates an MD5-based cache key from field selections and build options.
 *
 * The key is generated by serializing the root type, field structure, and options
 * into a deterministic string, then hashing it with MD5. This ensures consistent
 * keys for identical queries while maintaining reasonable key size.
 *
 * @param rootType - The root field name
 * @param fields - The field selections to include in the key
 * @param options - Build options that affect the generated query
 * @returns A 32-character hexadecimal MD5 hash string
 *
 * @example
 * ```typescript
 * const key = generateCacheKey('user', fields, {
 *   operationName: 'GetUser',
 *   variables: { id: '123' }
 * });
 * // Returns: 'a1b2c3d4e5f6...'
 * ```
 *
 * @remarks
 * The serialization is deterministic - identical inputs always produce the same key,
 * even if object properties are in different orders.
 */
export function generateCacheKey(
  rootType: string,
  fields: FieldSelection[],
  options: QueryBuildOptions = {},
): string {
  const structure = serializeFields(fields);
  const optionsStr = serializeOptions(options);
  return md5(`${rootType}:${structure}:${optionsStr}`);
}

/**
 * Serializes field selections to a deterministic string.
 */
function serializeFields(fields: FieldSelection[]): string {
  const sorted = [...fields].sort((a, b) => a.name.localeCompare(b.name));
  return sorted.map(serializeField).join(',');
}

function serializeField(field: FieldSelection): string {
  let result = field.name;
  if (field.alias) result = `${field.alias}:${result}`;
  if (field.arguments) {
    const argKeys = Object.keys(field.arguments).sort().join('+');
    result += `(${argKeys})`;
  }
  if (field.selections?.length) {
    result += `{${serializeFields(field.selections)}}`;
  }
  return result;
}

function serializeOptions(options: QueryBuildOptions): string {
  const parts: string[] = [];
  if (options.operationName) parts.push(`op:${options.operationName}`);
  if (options.operationType) parts.push(`type:${options.operationType}`);
  if (options.requiredFields?.length) parts.push(`req:${options.requiredFields.sort().join('+')}`);
  if (options.variableTypes && Object.keys(options.variableTypes).length > 0) {
    const types = Object.entries(options.variableTypes)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([k, v]) => `${k}:${v}`)
      .join('+');
    parts.push(`vars:${types}`);
  }
  if (options.rootArguments && Object.keys(options.rootArguments).length > 0) {
    parts.push(`root:${serializeArguments(options.rootArguments)}`);
  }
  if (options.fieldMappings && Object.keys(options.fieldMappings).length > 0) {
    const mappings = Object.entries(options.fieldMappings)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([k, v]) => `${k}=${v}`)
      .join('+');
    parts.push(`map:${mappings}`);
  }
  return parts.length > 0 ? parts.join('|') : '_';
}

function serializeArguments(args: Record<string, unknown>): string {
  const entries = Object.entries(args).sort(([a], [b]) => a.localeCompare(b));
  return entries.map(([key, value]) => `${key}=${serializeArgumentValue(value)}`).join(',');
}

function serializeArgumentValue(value: unknown): string {
  if (value === null) return 'null';
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return JSON.stringify(value);
  }

  if (Array.isArray(value)) {
    return `[${value.map(serializeArgumentValue).join(',')}]`;
  }

  if (typeof value === 'object' && value !== null) {
    if ('__variable' in value) {
      const v = value as { __variable: unknown };
      return typeof v.__variable === 'string' ? `$${v.__variable}` : '$';
    }

    const entries = Object.entries(value as Record<string, unknown>).sort(([a], [b]) =>
      a.localeCompare(b),
    );
    return `{${entries.map(([k, v]) => `${k}:${serializeArgumentValue(v)}`).join(',')}}`;
  }

  return JSON.stringify(String(value));
}

/**
 * Retrieves a cached query by its cache key.
 *
 * Checks for TTL expiration if configured, automatically evicting expired entries.
 * Updates cache statistics (hits/misses) with each call.
 *
 * @param key - The cache key (typically from {@link generateCacheKey})
 * @returns The cached query if found and valid, `undefined` otherwise
 *
 * @example
 * ```typescript
 * const key = generateCacheKey('user', fields, options);
 * const cached = getCachedQuery(key);
 * if (cached) {
 *   console.log('Cache hit!');
 * }
 * ```
 *
 * @see {@link setCachedQuery} to store a query in the cache
 * @see {@link generateCacheKey} to generate cache keys
 */
export function getCachedQuery(key: string): BuiltQuery | undefined {
  if (!cache) return undefined;

  const entry = cache.get(key);
  if (!entry) {
    stats.misses++;
    updateHitRatio();
    return undefined;
  }

  // Check TTL
  if (config.ttl > 0 && Date.now() - entry.timestamp > config.ttl) {
    cache.delete(key);
    stats.size = cache.size;
    stats.misses++;
    updateHitRatio();
    return undefined;
  }

  stats.hits++;
  updateHitRatio();
  return entry.query;
}

/**
 * Stores a query in the cache with the specified key.
 *
 * If the cache is at maximum capacity, the oldest entry (first inserted)
 * will be evicted to make room for the new entry (LRU strategy).
 *
 * @param key - The cache key (typically from {@link generateCacheKey})
 * @param query - The built query to cache
 *
 * @example
 * ```typescript
 * const key = generateCacheKey('user', fields, options);
 * const query = buildQuery('user', fields, options);
 * setCachedQuery(key, query);
 * ```
 *
 * @remarks
 * Each entry stores a timestamp for TTL-based expiration checks.
 *
 * @see {@link getCachedQuery} to retrieve cached queries
 * @see {@link initializeCache} to configure maxSize
 */
export function setCachedQuery(key: string, query: BuiltQuery): void {
  if (!cache) return;

  // Evict oldest entry if at capacity
  if (cache.size >= config.maxSize) {
    const oldestKey = cache.keys().next().value;
    if (oldestKey) cache.delete(oldestKey);
  }

  cache.set(key, { query, timestamp: Date.now() });
  stats.size = cache.size;
}

function updateHitRatio(): void {
  const total = stats.hits + stats.misses;
  stats.hitRatio = total > 0 ? stats.hits / total : 0;
}
